import Database from 'better-sqlite3';
import { TournamentRosterEntry } from '../../shared/schemas';
import { tournamentHistoryRepository } from './tournamentHistoryRepository';
import { calculateAgeCategory } from '../../shared/judo/calculateAgeCategory';

export class TournamentRosterRepository {
    constructor(private db: Database.Database) { }

    addAthlete(tournamentId: number, athleteId: number, weightClass: string): void {
        // Get tournament details
        const tournament = this.db.prepare(`
            SELECT id, name, date, location, ruleset_snapshot
            FROM tournaments
            WHERE id = ?
        `).get(tournamentId) as { id: number; name: string; date: string; location: string | null; ruleset_snapshot: string } | undefined;

        if (!tournament) {
            throw new Error(`Tournament with ID ${tournamentId} not found`);
        }

        // Get athlete details
        const athlete = this.db.prepare(`
            SELECT id, birthDate, gender
            FROM athletes
            WHERE id = ?
        `).get(athleteId) as { id: number; birthDate: string; gender: 'male' | 'female' } | undefined;

        if (!athlete) {
            throw new Error(`Athlete with ID ${athleteId} not found`);
        }

        // Parse ruleset to get age categories
        let ageCategory = 'Unclassified';
        try {
            const ruleset = JSON.parse(tournament.ruleset_snapshot);
            const tournamentYear = parseInt(tournament.date.split('-')[0], 10);
            ageCategory = calculateAgeCategory(
                athlete.birthDate,
                athlete.gender,
                ruleset.categories || [],
                tournamentYear
            );
        } catch (error) {
            console.error('Failed to calculate age category:', error);
        }

        // Use transaction to ensure atomicity
        const transaction = this.db.transaction(() => {
            // Insert into tournament_rosters
            const stmt = this.db.prepare(`
                INSERT OR IGNORE INTO tournament_rosters (tournament_id, athlete_id, weight_class)
                VALUES (?, ?, ?)
            `);
            stmt.run(tournamentId, athleteId, weightClass);

            // Create auto-generated tournament history entry
            tournamentHistoryRepository.addHistory({
                athlete_id: athleteId,
                tournament_id: tournamentId,
                tournament_name: tournament.name,
                tournament_date: tournament.date,
                tournament_location: tournament.location || undefined,
                weight_class: weightClass,
                age_category: ageCategory,
                is_auto_generated: true,
            });
        });

        transaction();
    }

    removeAthlete(tournamentId: number, athleteId: number): boolean {
        // Use transaction to ensure atomicity
        const transaction = this.db.transaction(() => {
            // Delete from tournament_rosters
            const stmt = this.db.prepare(`
                DELETE FROM tournament_rosters
                WHERE tournament_id = ? AND athlete_id = ?
            `);
            const info = stmt.run(tournamentId, athleteId);

            // Delete corresponding auto-generated history entry
            if (info.changes > 0) {
                tournamentHistoryRepository.deleteAutoGeneratedByTournamentAndAthlete(tournamentId, athleteId);
            }

            return info.changes > 0;
        });

        return transaction();
    }

    getRoster(tournamentId: number): TournamentRosterEntry[] {
        const stmt = this.db.prepare(`
            SELECT * FROM tournament_rosters
            WHERE tournament_id = ?
            ORDER BY added_at ASC
        `);

        return stmt.all(tournamentId) as TournamentRosterEntry[];
    }

    clearRoster(tournamentId: number): boolean {
        // Use transaction to ensure atomicity
        const transaction = this.db.transaction(() => {
            // Get all athletes in the roster before clearing
            const athletes = this.db.prepare(`
                SELECT athlete_id FROM tournament_rosters
                WHERE tournament_id = ?
            `).all(tournamentId) as { athlete_id: number }[];

            // Delete from tournament_rosters
            const stmt = this.db.prepare(`
                DELETE FROM tournament_rosters
                WHERE tournament_id = ?
            `);
            const info = stmt.run(tournamentId);

            // Delete all auto-generated history entries for this tournament
            if (info.changes > 0) {
                for (const { athlete_id } of athletes) {
                    tournamentHistoryRepository.deleteAutoGeneratedByTournamentAndAthlete(tournamentId, athlete_id);
                }
            }

            return info.changes > 0;
        });

        return transaction();
    }

    saveRoster(tournamentId: number, entries: Array<{ athleteId: number; weightClass: string }>): void {
        const transaction = this.db.transaction(() => {
            // Get current roster to determine what's being removed
            const currentRoster = this.getRoster(tournamentId);
            const currentAthleteIds = new Set(currentRoster.map(r => r.athlete_id));
            const newAthleteIds = new Set(entries.map(e => e.athleteId));

            // Find athletes being removed
            const removedAthleteIds = [...currentAthleteIds].filter(id => !newAthleteIds.has(id));

            // Clear existing roster
            this.db.prepare(`
                DELETE FROM tournament_rosters
                WHERE tournament_id = ?
            `).run(tournamentId);

            // Delete history for removed athletes
            for (const athleteId of removedAthleteIds) {
                tournamentHistoryRepository.deleteAutoGeneratedByTournamentAndAthlete(tournamentId, athleteId);
            }

            // Insert new entries (this will create history for new athletes)
            for (const entry of entries) {
                // Check if this is a new athlete (not in current roster)
                const isNewAthlete = !currentAthleteIds.has(entry.athleteId);

                // Insert into roster
                this.db.prepare(`
                    INSERT INTO tournament_rosters (tournament_id, athlete_id, weight_class)
                    VALUES (?, ?, ?)
                `).run(tournamentId, entry.athleteId, entry.weightClass);

                // Only create history for newly added athletes
                if (isNewAthlete) {
                    // Get tournament and athlete details
                    const tournament = this.db.prepare(`
                        SELECT id, name, date, location, ruleset_snapshot
                        FROM tournaments
                        WHERE id = ?
                    `).get(tournamentId) as { id: number; name: string; date: string; location: string | null; ruleset_snapshot: string } | undefined;

                    const athlete = this.db.prepare(`
                        SELECT id, birthDate, gender
                        FROM athletes
                        WHERE id = ?
                    `).get(entry.athleteId) as { id: number; birthDate: string; gender: 'male' | 'female' } | undefined;

                    if (tournament && athlete) {
                        // Calculate age category
                        let ageCategory = 'Unclassified';
                        try {
                            const ruleset = JSON.parse(tournament.ruleset_snapshot);
                            const tournamentYear = parseInt(tournament.date.split('-')[0], 10);
                            ageCategory = calculateAgeCategory(
                                athlete.birthDate,
                                athlete.gender,
                                ruleset.categories || [],
                                tournamentYear
                            );
                        } catch (error) {
                            console.error('Failed to calculate age category:', error);
                        }

                        // Create history entry
                        tournamentHistoryRepository.addHistory({
                            athlete_id: entry.athleteId,
                            tournament_id: tournamentId,
                            tournament_name: tournament.name,
                            tournament_date: tournament.date,
                            tournament_location: tournament.location || undefined,
                            weight_class: entry.weightClass,
                            age_category: ageCategory,
                            is_auto_generated: true,
                        });
                    }
                }
            }
        });

        transaction();
    }
}

